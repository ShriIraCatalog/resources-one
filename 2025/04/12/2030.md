# Chapter 9: Object Oriented Programming Part 1

We have covered a fair bit so far. In the next two chapters, we are going to look at another important concept in Python programming - the concept of object-oriented programming.

In this chapter, we'll learn what object-oriented programming is and how we can write our own classes and create objects from them. In the next chapter, we'll discuss inheritance and cover some other advanced topics in object-oriented programming.

Let's get started!

## 9.1 What is Object-Oriented Programming?

Simply stated, object-oriented programming is an approach to programming that breaks a programming problem into objects that interact with each other.

Objects are created from templates known as classes. You can think of a class as the blueprint of a building. An object is the actual "building" that we build based on the blueprint.

To understand how object-oriented programming works, let's start by coding a simple class together.

## 9.2 Writing our own class

To write our own class, we use the class keyword followed by the name of the class.

For instance, to create a Staff class, we write

```
class Staff:
    # contents of the class
```

It is common practice to use PascalCasing when naming our classes. PascalCasing refers to the practice of capitalizing the first letter of each word, including the first word (e.g. ThisIsAClassName). This is the convention that we'll be following in the book.

A class consists of variables and functions. As we learned in previous chapters, variables are for storing data while functions are code blocks that perform certain tasks for us. If a function exists within a class, it is more commonly referred to as a method.

You can think of a class as a template for grouping related data and methods together.

For instance, supposed we have a class called Staff. This class can be used to store all the relevant information about a staff in the company. Within the class, we can declare two variables to store the name and position of the staff. In addition, we can also code a method called `calculatePay()` to calculate the pay of the staff.

Let's look at how to do that.

Fire up IDLE and create a new file called `classdemo.py`. Add the following code to `classdemo.py`.

```
class Staff:
    def __init__(self, pPosition, pName, pPay):
        self.position = pPosition
        self.name = pName
        self.pay = pPay
        print('Creating Staff object')
    
    def __str__(self):
        return "Position = %s, Name = %s, Pay = %d"%(self.position, self.name, self.py)
    
    def calculatePay(self):
        prompt = '\nEnter number of hours worked for %s:'%(self.name)
        hours = input(prompt)
        prompt = 'Enter the hourly rate of %s:'%(self.name)
        hourlyRate = input(prompt)
        self.pay = int(hours) * int(hourlyRate)
        return self.py
```

In the code above, we first define a class called Staff by writing

```
class Staff:
```

Next, we define a special method called `__init__` for the class. This is known as the initializer of the class. It is always named init with two underscores in front and at the back. Python comes with a large number of special methods. All special methods have two underscores in front and at the back of their names. We'll discuss special methods in Chapter 10.4 later.

An initializer is called whenever an object of the class is created. Do not worry if you don't know what this means. We'll learn how to create an object of the class later.

For now, all that you have to know is an initializer is frequently used to initialize the variables (i.e give them initial values) in the class.

In our class, we have three variables - position, name and pay. These variables are known as instance variables, in contrast to local variables (covered in Chapter 7.3) and class variables (to be covered later in Chapter 9.6). Instance variables are variables that are prefixed with a `self` keyword.

The `self` keyword is hard to explain at this stage. Simply stated, `self` refers to an instance itself. This statement probably sounds abstract to you. We'll explore the meaning of self in a later section. For now, just know that when we want to refer to instance variables in the class, we need to add self in front of the variable names. In addition, most methods in a class have self as the first parameter.

The three statements below assign three parameters of the `__init__` method (pPosition, pName and pPay) to the instance variables to initialize them.

```
self.position = pPosition
self.name = pName
self.pay = pPay
```

After initializing the three instance variables, we print out a simple statement 'Creating Staff object'. That's all that the initializer does.

Writing an initializer is optional if you do not wish to initialize the instance variables when you create the object. You can always initialize them later.

Let's move on to the next method - `__str__`

`__str__` is another special method that is commonly included when we code a class. We use it to return a human readable string that represents the class. In our example, we simply return a string that gives the values of the three instance variables. We'll look at how we use this method later.

Now, let's move on to the `calculatePay()` method.

`calculatePay()` is a method that is used to calculate the pay of a staff. You'll notice that it is very similar to a function, except for the parameter `self`. Indeed, a method is almost identical to a function except that a method exists inside a class and most methods have `self` as a parameter.

Within the `calculatePay()` method, we first prompt the user to enter the number of hours worked for the staff. Next, we prompt for the hourly rate and calculate the pay based on these two values. We then assign the result to the instance variable `self.py` and return the value of `self.pay`.

You may notice that in this method, we do not add self in front of some variables (such as prompt, hours and hourlyRate). This is because these variables are local variables and only exist within the `calculatePay()` method. We do not need to add `self` in front of local variables.

That's all there is to the class that we wrote. To recap, our class has the following components

### Instance Variables

```
position
name
pay
```

### Methods
```
__init__
__str__
calculatePay()
```

## 9.3 Instantiating an Object



